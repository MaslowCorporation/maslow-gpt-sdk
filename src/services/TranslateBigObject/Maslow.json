{
  "question": "Give me a Typescript function called TranslateBigObject({\n  model_chosen,\n  obj,\n  language,\n  apiKey,\n  retries = 10,\n  progressIntervalMs = 1000,\n  onJobCreated,\n  onSuccess,\n  onError,\n  onProgress,\n  print = false,\n  jobId,\n}: {\n  model_chosen?: string;\n  apiKey: string;\n  obj: any;\n  language: string;\n  retries?: number;\n  progressIntervalMs: number,\n  onProgress?: (progress: TranslateObjectStatus) => void;\n  onSuccess?: (output: any) => void;\n  onJobCreated?: (jobId: string) => void;\n  onError?: (error: any) => void;\n  print?: boolean;\n  jobId?: string;\n}): Promise<object {answer, usage} or null> {\n  \n}\n\nwrap the whole thing in a try/catch block. In the catch block, \nrun the onError callback if existing, with the error as arg,\nand return null.\n\nFirst, \n\nIf obj contains more than 15 keys, cut the object obj in an array of subobjects named subObjects each sub object containing max 15 keys.\n\nif obj contains 15 or less keys, put this obj in a subObjects array containing this obj alone.\n\nNow, with our subObjects array, run the following code for each individualSubObject in subObjects:\n\nconst translatedObjDataRaw = await MaslowGPTSDK.GetGPTCode({\n    model_chosen,\n    prompt: `Translate all the key values of ${JSON.stringify(individualSubObject)} to ${language}`,\n    onSuccess: (chatGPTOutput) => { },\n    onProgress: (progress) => { },\n    onError: (e) => {  },\n    apiKey,\n});\n\nif any of the translatedObjDataRaw is null, throw an error with message \"The object translation failed. Try again\"\n\notherwise create an array of all the translatedObjDataRaw results, in the same order as the subObjects.\n\nEach translatedObjDataRaw is a { \n  answer: { \n    answer: string, \n    codePart: string, // codePart is a JSON string containing the translated object \n  }, \n  usage: {\n    \"inputCostDollar\": number,\n    \"outputCostDollar\": number,\n    \"feeDollar\": number,\n    \"totalCostDollar\": number,\n    \"totalCostAPICredits\": number,\n    \"APICreditsLeft\": number\n  } \n} \n\nobject.\n\neach codePart contains a JSON string containing the translated object.\n\nnow parse each translatedObjDataRaw.answer.codePart string into a object, \nand merge all the parsed objects into a big object,\nnamed bigTranslatedObject.\n\nalso, create a object totalCost, an object {\n   \"inputCostDollar\": <The result of adding together every translatedObjDataRaw.usage.inputCostDollar>,\n   \"outputCostDollar\": <The result of adding together every translatedObjDataRaw.usage.outputCostDollar>,\n   \"feeDollar\": <The result of adding together every translatedObjDataRaw.usage.feeDollar>,\n   \"totalCostDollar\": <The result of adding together every translatedObjDataRaw.usage.totalCostDollar>,\n   \"totalCostAPICredits\": <The result of adding together every translatedObjDataRaw.usage.inputCostAPICredits>,\n   \"APICreditsLeft\": <The last translatedObjDataRaw.usage.APICreditsLeft in the array of translatedObjDataRaw>\n}\n\nmade from the array of translatedObjDataRaw.\n\nOnce done, create a variable result, a {\n  answer: bigTranslatedObject,\n  usage: totalCost\n} object.\n\nrun the onSuccess callback, if existing, with result as arg.\n\nand finally, after all this hard work, return result.",
  "questionPath": "question.txt",
  "answer": {
    "codePart": "async function TranslateBigObject({\n  model_chosen,\n  obj,\n  language,\n  apiKey,\n  retries = 10,\n  progressIntervalMs = 1000,\n  onJobCreated,\n  onSuccess,\n  onError,\n  onProgress,\n  print = false,\n  jobId,\n}: {\n  model_chosen?: string;\n  apiKey: string;\n  obj: any;\n  language: string;\n  retries?: number;\n  progressIntervalMs: number,\n  onProgress?: (progress: TranslateObjectStatus) => void;\n  onSuccess?: (output: any) => void;\n  onJobCreated?: (jobId: string) => void;\n  onError?: (error: any) => void;\n  print?: boolean;\n  jobId?: string;\n}): Promise<object | null> {\n  try {\n    // Split obj into subobjects if it contains more than 15 keys\n    const subObjects = [];\n    if (Object.keys(obj).length > 15) {\n      let keys = Object.keys(obj);\n      while (keys.length > 0) {\n        subObjects.push(\n          keys.splice(0, 15).reduce((acc, key) => {\n            acc[key] = obj[key];\n            return acc;\n          }, {})\n        );\n      }\n    } else {\n      subObjects.push(obj);\n    }\n\n    const translatedObjDataRawPromises = subObjects.map(async (individualSubObject) => {\n      return await MaslowGPTSDK.GetGPTCode({\n        model_chosen,\n        prompt: `Translate all the key values of ${JSON.stringify(individualSubObject)} to ${language}`,\n        onSuccess: (chatGPTOutput) => { },\n        onProgress: (progress) => { },\n        onError: (e) => { },\n        apiKey,\n      });\n    });\n\n    const translatedObjDataRawResults = await Promise.all(translatedObjDataRawPromises);\n\n    if (translatedObjDataRawResults.some((result) => result === null)) {\n      throw new Error(\"The object translation failed. Try again\");\n    }\n\n    const translatedObjects = translatedObjDataRawResults.map((translatedObjDataRaw) => {\n      const codePartObj = JSON.parse(translatedObjDataRaw.answer.codePart);\n      return codePartObj;\n    });\n\n    const bigTranslatedObject = Object.assign({}, ...translatedObjects);\n\n    const totalCost = translatedObjDataRawResults.reduce(\n      (acc, translatedObjDataRaw) => {\n        const usage = translatedObjDataRaw.usage;\n        acc.inputCostDollar += usage.inputCostDollar;\n        acc.outputCostDollar += usage.outputCostDollar;\n        acc.feeDollar += usage.feeDollar;\n        acc.totalCostDollar += usage.totalCostDollar;\n        acc.totalCostAPICredits += usage.totalCostAPICredits;\n        acc.APICreditsLeft = usage.APICreditsLeft;\n        return acc;\n      },\n      {\n        inputCostDollar: 0,\n        outputCostDollar: 0,\n        feeDollar: 0,\n        totalCostDollar: 0,\n        totalCostAPICredits: 0,\n        APICreditsLeft: 0,\n      }\n    );\n\n    const result = {\n      answer: bigTranslatedObject,\n      usage: totalCost,\n    };\n\n    if (onSuccess) {\n      onSuccess(result);\n    }\n\n    return result;\n  } catch (error) {\n    if (onError) {\n      onError(error);\n    }\n    return null;\n  }\n}\n",
    "answer": "Here is the TypeScript function \"TranslateBigObject\" wrapped in a try/catch block and implementing the logic you described:\n\n```typescript\nasync function TranslateBigObject({\n  model_chosen,\n  obj,\n  language,\n  apiKey,\n  retries = 10,\n  progressIntervalMs = 1000,\n  onJobCreated,\n  onSuccess,\n  onError,\n  onProgress,\n  print = false,\n  jobId,\n}: {\n  model_chosen?: string;\n  apiKey: string;\n  obj: any;\n  language: string;\n  retries?: number;\n  progressIntervalMs: number,\n  onProgress?: (progress: TranslateObjectStatus) => void;\n  onSuccess?: (output: any) => void;\n  onJobCreated?: (jobId: string) => void;\n  onError?: (error: any) => void;\n  print?: boolean;\n  jobId?: string;\n}): Promise<object | null> {\n  try {\n    // Split obj into subobjects if it contains more than 15 keys\n    const subObjects = [];\n    if (Object.keys(obj).length > 15) {\n      let keys = Object.keys(obj);\n      while (keys.length > 0) {\n        subObjects.push(\n          keys.splice(0, 15).reduce((acc, key) => {\n            acc[key] = obj[key];\n            return acc;\n          }, {})\n        );\n      }\n    } else {\n      subObjects.push(obj);\n    }\n\n    const translatedObjDataRawPromises = subObjects.map(async (individualSubObject) => {\n      return await MaslowGPTSDK.GetGPTCode({\n        model_chosen,\n        prompt: `Translate all the key values of ${JSON.stringify(individualSubObject)} to ${language}`,\n        onSuccess: (chatGPTOutput) => { },\n        onProgress: (progress) => { },\n        onError: (e) => { },\n        apiKey,\n      });\n    });\n\n    const translatedObjDataRawResults = await Promise.all(translatedObjDataRawPromises);\n\n    if (translatedObjDataRawResults.some((result) => result === null)) {\n      throw new Error(\"The object translation failed. Try again\");\n    }\n\n    const translatedObjects = translatedObjDataRawResults.map((translatedObjDataRaw) => {\n      const codePartObj = JSON.parse(translatedObjDataRaw.answer.codePart);\n      return codePartObj;\n    });\n\n    const bigTranslatedObject = Object.assign({}, ...translatedObjects);\n\n    const totalCost = translatedObjDataRawResults.reduce(\n      (acc, translatedObjDataRaw) => {\n        const usage = translatedObjDataRaw.usage;\n        acc.inputCostDollar += usage.inputCostDollar;\n        acc.outputCostDollar += usage.outputCostDollar;\n        acc.feeDollar += usage.feeDollar;\n        acc.totalCostDollar += usage.totalCostDollar;\n        acc.totalCostAPICredits += usage.totalCostAPICredits;\n        acc.APICreditsLeft = usage.APICreditsLeft;\n        return acc;\n      },\n      {\n        inputCostDollar: 0,\n        outputCostDollar: 0,\n        feeDollar: 0,\n        totalCostDollar: 0,\n        totalCostAPICredits: 0,\n        APICreditsLeft: 0,\n      }\n    );\n\n    const result = {\n      answer: bigTranslatedObject,\n      usage: totalCost,\n    };\n\n    if (onSuccess) {\n      onSuccess(result);\n    }\n\n    return result;\n  } catch (error) {\n    if (onError) {\n      onError(error);\n    }\n    return null;\n  }\n}\n```\n\nNote: The implementation assumes that the `MaslowGPTSDK.GetGPTCode` function returns a promise. Please make sure to replace `MaslowGPTSDK.GetGPTCode` with the actual function that performs the translation.\n"
  },
  "codeFilePath": "TranslateBigObject.ts"
}